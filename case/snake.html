<!DOCTYPE html>
<html lang="en">
<body>  
    <canvas id="can" width="400" height="400" style="background: black"></canvas>  
    <script>  
        var sn = [ 42, 41 ], dz = 43, fx = 1, n, ctx = document.getElementById("can").getContext("2d"); 
        //  蛇        食物      方向  蛇新走到的位置   
        //画格子
        function draw(t, c) {  
            ctx.fillStyle = c;  
            ctx.fillRect(t % 20 * 20 + 1, ~~(t / 20) * 20 + 1, 18, 18);  
        }  
        document.onkeydown = function(e) {  
            // 方向键 左, 上, 右, 下的keyCode分别为37, 38, 39, 40
            // 如果用户按下这几个键, 会改变蛇头下一次的位置到对应的方向上
            // 如果不是这几个键, 则不会变动,
            // 别问我这句话怎么实现的,谢谢!
            n = [ -1, -20, 1, 20 ][(e || event).keyCode - 37] || fx;
                //左,  上 , 右, 下一一对应
            // 如果按键的方向和蛇当前前进的方向相反, 则不改动
            fx = sn[1] - sn[0] == n ? fx : n ;
            // console.log(n);
            // console.log(fx);
        };  
            
        !function() {  //自调用
            sn.unshift(n = sn[0] + fx);//向坐标头压入一个新的方块
            // console.log(n);
            // console.log(fx); 
            //向数组的开头添加一个或更多元素，并返回新的长度
            if (sn.indexOf(n, 1) > 0 //检索n是否在sn中存在,有则撞到了自己
                || n<0||n>399 //纵向边界
                || fx == 1 && n % 20 == 0 //撞右侧墙.反方向值不变
                || fx == -1 && n % 20 == 19){ //撞左侧墙
            //返回某个指定的字符串值在字符串中首次出现的位置。
                // console.log(n);
                // console.log(fx); 
                return alert("GAME OVER");  
            }
            draw(n, "Lime");  
            //绘出这个方块N
            if (n == dz) {  //第一次执行 随机出现小黄球（食物）也就是说只要吃了小黄球一次就会变长    
                while ( sn.indexOf(dz = ~~(Math.random() * 400)) >= 0);//食物不在蛇身上  
                draw(dz, "Yellow");
            } else  
                draw(sn.pop(), "Black");  //非食物,删除蛇尾,并涂黑
                setTimeout(arguments.callee, 100); //递归调用 
        }();



        // //其他
        // //ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
        // let a = new Set([1, 2, 3]);let b = new Set([3, 5, 2]); 
        // // 并集 
        // let unionSet = new Set([...a, ...b]); //[1,2,3,5]
        // // 交集 
        // let intersectionSet = new Set([...a].filter(x => b.has(x)));// [2,3] 
        // // ab差集 
        // let differenceABSet = new Set([...a].filter(x => !b.has(x))); // [1]
        // console.log(unionSet,intersectionSet,differenceABSet); 
    </script>  
</body>  
</html>  